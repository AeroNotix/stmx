TO DO:

8) contact Lars Rune Nostdal <larsnostdal at gmail dot com>, author of SW-STM:
   see http://blog.nostdal.org/
   "I have a very crude and quite horribly written one laying around for
    Common Lisp: https://github.com/lnostdal/SW-STM"

DONE:

7bis) implement transactional red-black trees

7) implemented red-black trees (needed for transactional red-black trees)

6bis) implement (thash-count)

6) implemented transactional hash tables

5) implemented before-commit and after-commit (idea from SW-STM when-commit)

4.2) optimize nested transaction. Copying all the parent TLOG reads and writes is slow,
     so merge only reads-of log1 log2 when retrying a nested transaction
     and simply replace reads and writes of parent tlog when committing a nested transaction

4.1) test that errors signalled by an invalid transaction are *not* propagated to the caller
     and the transaction is re-executed

4) orelse and nested transactions, including tests

3) (error 'retry-error ...) shows message "attempt to RETRY outside ATOMIC block"
   when printed

2) in atomic.lisp (run-once) added handler-case to capture errors signaled by tx

1) implemented ($ tvar) and (setf ($ tvar) value)
   for transactional access to tvars.
   useful when dealing directly with tvars,
   for example in cases transactional objects are too heavyweight


WON'T DO:
4.3) allow orelse/nonblocking to work even without a parent transaction,
     i.e. outside (atomic ...) ?
     NO. the overhead of (atomic (orelse ...)) is minimal with respect to
     bare (orelse ...), and the former is clearer to understand.
     Also, doing this would make orelse implementation slower and even more
     complicated than what already is.

